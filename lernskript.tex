\documentclass[11pt,a4paper]{scrartcl}
\usepackage[utf8]{inputenc}
\usepackage[ngerman]{babel}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{makeidx}
\usepackage{hyperref}
\usepackage{colortbl}
\usepackage{listings}
\usepackage{chngcntr}
\usepackage{upgreek}
\usepackage{pgfplots}
\pgfplotsset{compat = newest}
\usepackage{amsthm}
\usepackage{ulem}
\usepackage{tikz}
\usepackage{graphicx}
\usetikzlibrary{positioning}
\usepackage{tikz-network}
\usepackage[left=3cm,right=3cm,top=3cm,bottom=3cm]{geometry}

\usepackage[backend=biber, style=alphabetic]{biblatex}
\addbibresource{literature.bib}
\author{Roman Wetenkamp}
\title{Systemnahe Programmierung}
\subtitle{Technische Informatik II}

\newtheorem{note}{Bemerkung}
\newtheorem{definition}{Definition}
\newtheorem{satz}{Satz}
\newtheorem{theorem}{Theorem}
\newtheorem{lemma}{Lemma}
\newtheorem{example}{Beispiel}


\begin{document}
\vspace{3cm}
\maketitle
\begin{center}
\includegraphics[scale=0.7]{DHBW.jpg}
\end{center}
\pagebreak
\tableofcontents
\pagebreak
\section*{Vorwort}
Systemnah Programmieren - Klingt komplizierter als es ist. Hier notieren wir alles Relevante aus der Vorlesung, ergänzen es um ein paar Aufgaben und Anmerkungen und bereiten uns auf die Klausur vor. Dieses Skript basiert auf der Vorlesung von Joachim Wagner an der DHBW Mannheim im Studiengang Informatik -- Cyber Security. \\\\
\textit{Viel Erfolg!}  \\
\begin{flushright}
Roman Wetenkamp \\
Mannheim, den \today
\end{flushright}  
\vfill
\paragraph{Warnung}
Das Studium an einer Dualen Hochschule unterscheidet sich von dem Studium an Universitäten oder regulären Fachhochschulen insbesondere dadurch, dass aufgrund der Dualität von Theorie und Praxis meist nur die Hälfte der Zeit zur Vermittlung des Stoffes zur Verfügung steht (wenn dann auch intensiver). Daher gehen Sie bitte nicht davon aus, dass Sie dieses Skript ausreichend auf Klausuren in regulären Vollzeitstudiengängen vorbereitet!
\paragraph{Hinweis}
Dieses Dokument ist kein Vorlesungsmaterial, hat nicht den Anspruch auf {Voll}\-{ständigkeit} und enthält mit Sicherheit Fehler. Desweiteren ist es noch lange nicht vollendet (es ist infrage zustellen, ob es das je sein wird), und doch möchte ich Sie ermutigen, beizutragen! Jegliche Fehler, Probleme oder Anmerkungen können Sie mir gerne über das dazugehörige GitHub-Repository unter der URL \url{https://github.com/RWetenkamp/kommnet} zukommen lassen. Danke!
\pagebreak

\section{Einführung}
Systemnah zu programmieren bedeutet zuallererst, viele Ebenen der Abstraktion, die Betriebssysteme oder Virtualisierungen hinter sich zu lassen und zurückzukehren zu dem grundlegendsten Konzept der Computertechnik, dem Bit. \\
\begin{definition}
Ein Bit ist die kleinste Speichereinheit eines Computersystems. Der Wert eines Bits ist entweder \textbf{0} für \textbf{aus} oder \textbf{1} für \textbf{ein}. Sprechen wir von einem 8-Bit-Register, so bezeichnen wir damit acht einzeln adressierbare Werte, die jeweils auf 0 oder 1 gesetzt werden können. 
\[8 \text{ Bit } \widehat{=} 1 \text{ Byte }\]
\end{definition}

Sie werden in Ihren Programmen verschiedene Bitoperationen implementieren müssen, da die zugrundliegende Hardware zu großen Teilen aus Registern besteht, die sie auf diese Weise ansprechen können.
\begin{table}[h]
\centering
\begin{tabular}{|l|c|c|c|c|c|}
\hline
Bezeichnung & Symbol & C-Operatorsymbol & $a$ & $b$ & Ergebnis \\
\hline
Konjunktion & $\land$ & \texttt{\&} & 0 & 0 & 0 \\
&&&0 & 1 & 0 \\
&&&1 & 0 & 0 \\
&&&1 & 1 & 1 \\
\hline
Disjunktion & $\lor$ & \texttt{|} & 0 & 0 & 0 \\
&&&0 & 1 & 1 \\
&&&1 & 0 & 1 \\
&&&1 & 1 & 1 \\
\hline
XOR & $\oplus$ & \texttt{\^} & 0 & 0 & 0 \\
&&&0 & 1 & 1 \\
&&&1 & 0 & 1 \\
&&&1 & 1 & 0 \\
\hline
\end{tabular}
\caption{Übersicht über binäre Bitoperationen}
\end{table} \\

\begin{table}[h]
\centering
\begin{tabular}{|l|c|c|c|c|c|}
\hline
Bezeichnung & Symbol & C-Operatorsymbol & $a$ & Ergebnis \\
\hline
Negation & $\lnot$ & \texttt{~} & 0 & 1 \\
&&&1 & 0 \\
\hline
Linksverschiebung & &\texttt{<<} & 0000 & \texttt{1 << 1}: 0001, \texttt{1 << n}: 00...1...0 \\
\hline
Rechtsverschiebung & & \texttt{>>} & 1000 & \texttt{1 >> 1}: 0100, \texttt{1 << n}: 00...1...0 \\
\hline
\end{tabular}
\caption{Übersicht über unäre Bitoperationen}
\end{table}

Im folgenden Kapitel betrachten wir die verwendete Hardware und beginnen damit, die einzelnen Bestandteile und ihre Aufgaben zu erläutern. Wir werden jeweils anhand von Beispielprogrammen zeigen, wie die einzelnen Komponenten angesprochen und programmiert werden können. Die Programmiersprache hierfür ist C, in der Vorlesung wurde das {\glqq}Microchip Studio{\grqq} als IDE verwendet. Sie können es hier beziehen: \\
\url{https://www.microchip.com/en-us/development-tools-tools-and-software/microchip-studio-for-avr-and-sam-devices}

\section{Hardware}
Grundlegend ist Ihnen der Aufbau eines Computersystems sicherlich vertraut.
\begin{itemize}
\item Die \textbf{CPU} (Central Processing Unit), also der Prozessor, ist die zentrale Komponente, die die Befehle ausführt.
\item Während der Ausführung speichert die CPU Programmdaten im Arbeitsspeicher, dem \textbf{RAM} (Random Accessible Memory). Dieser Speicher wird nur zur Laufzeit genutzt und ist daher nicht persistent.
\item Ebenso gibt es einen Massenspeicher, eine Festplatte, auf der Daten persistent gespeichert werden und bei Bedarf gelesen/geschrieben werden.
\end{itemize}
Diese Grundstruktur gleicht im Wesentlichen dem \textsc{Von-Neumann-Prinzip} und ist sowohl auf klassische PCs anwendbar als auch auf Microcontroller, denen wir uns im Rahmen dieser Vorlesung widmen wollen.
\\
\begin{note}
Ein \textbf{Microcontroller} ist ein Minicomputer auf einem Chip. Er enthält einen Microprozessor und Speicher.
\end{note}
Ein solcher Microcontroller findet sich häufig auf Entwicklungsboards, wie z. B. der Arduino-Produktfamilie, die bereits aufgelötete Ports für weitere Komponenten enthalten. Derartige Boards gibt es zuhauf im Markt. Häufig sind die Unterschiede gering, da Arduino-Boards unter einer Open-Source-Lizenz stehen und somit von anderen ohne Weiteres kopiert werden dürfen. \\\\
Im Rahmen dieser Vorlesung arbeiten wir mit Arduino-Microcontrollern oder zu Arduino kompatiblen Äquivalenten. Die von uns verwendeten Boards enthalten allesamt folgenden Microprozessor:
\begin{center}
\textbf{ATMEL ATmega 328P}
\end{center}
Die Kenntnis des Microcontrollers ist unabdingbar für den weiteren Verlauf der Vorlesung. \\
Die Microcontroller Arduino Uno und Arduino Nano enthalten genannten Prozessor. Wir werden als Referenz jeweils den Arduino Uno verwenden.
\begin{figure}[h!]
\centering
\includegraphics[scale=0.4]{uno.png}
\caption{Arduino Uno mit ATMEL ATmega328P}
\end{figure}
\paragraph{Aufbau}
Dieser Microcontroller enthält einige relevante Komponenten, die über einen Bus mit der CPU verbunden sind. Wir entnehmen diese dem folgenden Blockschaltbild.
\begin{figure}[h!]
\centering
\includegraphics[scale=0.5]{b2-1.png}
\end{figure}
\begin{itemize}
\item \textbf{Flash} -- Der Flash-Speicher ist neben SRAM und EEPROM einer der drei Speichertypen. Der Flash-Speicher ist unveränderlich und kann lediglich von außen gebrannt werden. Hier wird das aktuelle Skript / Programm gespeichert.
\item \textbf{SRAM} -- Hierbei handelt es sich um einen winzig kleinen Arbeitsspeicher. Dieser Speicher ist nicht persistent und wird von der CPU während der Laufzeit verwaltet und verwendet.
\item \textbf{EEPROM} -- Dieser Speicher ist persistent und fungiert als {\glqq}Festplatte{\grqq}.
\item \textbf{Watchdog} -- Sollte der Chip nach einer gewissen Zeit kein Lebenssignal mehr senden, setzt der Watchdog den Microcontroller automatisch zurück.
\item \textbf{A/D Converter} -- Die Prozessoren der ATmega-Reihe können analoge Signale in digitale umwandeln. Dafür ist dieser Baustein zuständig.
\item \textbf{8/16bit T/C} -- Diese Bauteile sind Timer/Counter, die zur Prozesssteuerung genutzt werden können. Wir widmen uns diesen Bauteilen später.
\item \textbf{USART} -- Eine serielle Schnittstelle für diversen Datenverkehr ist der USART-Baustein.
\item \textbf{TWI} -- Die TWI-Schnittstelle kann für die Verknüpfung mehrerer Microcontroller untereinander genutzt werden.
\end{itemize}
Im Allgemeinen wird die Kommunikation mit jeder Hardware/CPU über I/O-Ports abgewickelt. 
\begin{note}
Gelegentlich kann es zu Verwirrung kommen, da sowohl internen I/O-Ports des Microcontrollers als auch die Anschlusspins für elektronische Bauteile als \textbf{Ports} bezeichnet werden. Im Kontext dieses Kurses bezeichnen wir letztere als {\glqq}Beinchen{\grqq}.
\end{note}
\paragraph{System} Der hier gezeigte Controller folgt der \textbf{RISC}-Architektur. RISC steht für {\glqq}Reduced Instruction Set Controller{\grqq}. Es hat sich gezeigt, dass mit einem im Vergleich zu Assembler reduzierten Befehlssatz ähnlich effizient, jedoch viel leichter dekodierbar und in der Regel schneller, gearbeitet werden kann. Der Microcontroller enthält von sich aus kein Betriebssystem. Wollen wir ein Programm ausführen, so müssen wir dieses speziell für diesen Microprozessor in einer hardwarenahen Programmiersprache wie Java oder C implementieren.
\section{Grundlegendes zur Programmierung}
Wir werden in dieser Vorlesung -- und damit auch in diesem Skript -- die Programmiersprache C verwenden. Um die benötigten Bibliotheken nutzen zu können, müssen die passenden Treiber installiert werden. Am einfachsten lässt sich dies durch die Arduino IDE und das zuvor erwähnte Microchip Studio realisieren. Das \textbf{Flashen}, also das Aufspielen der Programme auf das Board, erfolgt über USB.
\paragraph{Programmaufbau}
Wie Sie es von C gewohnt sein werden, unterscheiden wir \textbf{Programmzeilen} und \textbf{Präprozessordirektiven}. Die Befehle, die ausgeführt werden sollen, müssen Bestandteil der \texttt{main()}-Funktion des Programms sein.
\begin{note}
Jedes Programm, dass Sie flashen wollen, muss eine Endlosschleife enthalten! Andernfalls wird die Operation lediglich ein einziges Mal ausgeführt.
\end{note} 
Angewandt bedeutet dies:
\begin{lstlisting}[language=C]
#define F_CPU 16000000UL
#include <avr/io.h>

int main() {
	// Initialisierungen
	while(1) {
		// Hier koennen Sie Ihren Code platzieren	
	}
}
\end{lstlisting}
Sie erkennen die Definition der Konstante F{\_}CPU in der ersten Zeile. Hier legen wir fest, dass der Prozessor mit einem Takt von 16 MHz arbeitet.
\end{document}